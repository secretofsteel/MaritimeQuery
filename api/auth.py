"""JWT authentication utilities.

Reads credentials from config/users.yaml. Issues and verifies JWT tokens.
No FastAPI/HTTP dependencies — used by both dependencies.py and routes/auth.py.
"""

from __future__ import annotations

import logging
import os
import secrets
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any, Dict, Optional

import bcrypt
import yaml
from jose import JWTError, jwt

logger = logging.getLogger(__name__)

# --- Configuration ---

ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 24


def get_jwt_secret() -> str:
    """Get JWT signing secret from environment.

    Falls back to a generated secret with a warning (development only).
    A generated secret means all tokens invalidate on server restart.
    """
    secret = os.getenv("JWT_SECRET")
    if not secret:
        secret = secrets.token_hex(32)
        logger.warning(
            "JWT_SECRET not set — using generated secret. "
            "Tokens will not survive server restarts. "
            "Set JWT_SECRET in .env for production."
        )
    return secret


# Module-level secret, initialized once on first import.
JWT_SECRET: str = get_jwt_secret()


# --- Credential Loading ---

def _get_users_yaml_path() -> Path:
    """Resolve path to users.yaml config file."""
    from app.config import AppConfig
    config = AppConfig.get()
    return config.paths.base_dir / "config" / "users.yaml"


def load_credentials() -> Dict[str, Dict[str, Any]]:
    """Load user credentials from YAML file.

    Returns:
        Dict mapping username -> {name, password (hash), tenant_id, role}

    Raises:
        FileNotFoundError: If users.yaml doesn't exist.
        ValueError: If YAML is malformed or missing required sections.
    """
    path = _get_users_yaml_path()
    if not path.exists():
        raise FileNotFoundError(f"Auth config not found: {path}")

    with open(path) as f:
        config = yaml.safe_load(f)

    usernames = config.get("credentials", {}).get("usernames")
    if not usernames:
        raise ValueError("users.yaml missing credentials.usernames section")

    return usernames


# --- Password Verification ---

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a plain password against a bcrypt hash.

    Compatible with hashes generated by streamlit-authenticator's Hasher.
    """
    try:
        return bcrypt.checkpw(
            plain_password.encode("utf-8"),
            hashed_password.encode("utf-8"),
        )
    except Exception:
        return False


def authenticate_user(username: str, password: str) -> Optional[Dict[str, Any]]:
    """Authenticate a user against YAML credentials.

    Args:
        username: Login username.
        password: Plain text password.

    Returns:
        User dict {name, tenant_id, role} on success, None on failure.
    """
    try:
        users = load_credentials()
    except (FileNotFoundError, ValueError) as exc:
        logger.error("Failed to load credentials: %s", exc)
        return None

    user = users.get(username)
    if user is None:
        return None

    if not verify_password(password, user.get("password", "")):
        return None

    return {
        "username": username,
        "name": user.get("name", username),
        "tenant_id": user.get("tenant_id", "shared"),
        "role": user.get("role", "tenant"),
    }


# --- JWT Token Creation & Verification ---

def create_access_token(
    username: str,
    tenant_id: str,
    role: str,
    expires_hours: int = ACCESS_TOKEN_EXPIRE_HOURS,
) -> str:
    """Create a signed JWT access token.

    Payload:
        sub: username
        tenant_id: tenant identifier
        role: "superuser" or "tenant"
        exp: expiration timestamp
        iat: issued-at timestamp
    """
    now = datetime.now(timezone.utc)
    payload = {
        "sub": username,
        "tenant_id": tenant_id,
        "role": role,
        "exp": now + timedelta(hours=expires_hours),
        "iat": now,
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=ALGORITHM)


def decode_token(token: str) -> Dict[str, Any]:
    """Decode and verify a JWT token.

    Returns:
        Token payload dict.

    Raises:
        JWTError: If token is invalid, expired, or tampered with.
    """
    return jwt.decode(token, JWT_SECRET, algorithms=[ALGORITHM])
